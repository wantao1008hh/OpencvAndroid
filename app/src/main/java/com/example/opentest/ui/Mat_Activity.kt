package com.example.opentest.ui

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.opentest.R
import com.example.opentest.opencv.ImageUtil
import com.example.opentest.util.FileUtil
import com.warkiz.widget.IndicatorSeekBar
import com.warkiz.widget.OnSeekChangeListener
import com.warkiz.widget.SeekParams
import io.reactivex.rxjava3.android.schedulers.AndroidSchedulers
import io.reactivex.rxjava3.core.Observable
import io.reactivex.rxjava3.disposables.Disposable
import io.reactivex.rxjava3.schedulers.Schedulers
import kotlinx.android.synthetic.main.activity_mat.*
import org.opencv.core.*
import java.util.concurrent.TimeUnit


/**
 * author: 万涛
 * 2020-11-24 11:16
 *
 *
 * 学习构建 Mat（图像）
 *
 * 图像通道：
 *      OpenCV 中，图像可以分别为1，2，3，4 通道。
 *      -- 1 通道为灰度图；
 *      -- 2 通道的图像是RGB555和RGB565。2通道图在程序处理中会用到，如傅里叶变换，可能会用到，一个通道为实数，一个通道为虚数，主要是编程方便。RGB555是16位的，2个字节，5+6+5，第一字节的前5位是R，后三位+第二字节是G，第二字节后5位是B，可见对原图像进行压缩了
 *      -- 3 通道为彩色图（RGB）；
 *      -- 4 通道为 RGBA ，是RGB加上一个A通道，也叫alpha通道，表示透明度，PNG图像是一种典型的4通道图像。alpha通道可以赋值0到1，或者0到255，表示透明到不透明
 *
 *      ** 其中常见的是1通道和3通道，2通道和4通道不常见
 *
 * OpenCV CvType 说明：
 *
 * opencv 中表示图像的类型的常量，通过 CvType.[name] 调用。
 *
 * 1. CvType 格式
 *      -- CV_<bit_depth>(S|U|F)C<number_of_channels>
 *          +-- bit_depth [bite、比特数] , 有8bite，16bite，32bite，64bite
 *              如果你现在创建了一个存储 [灰度图] 片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张
 *              灰度图片中有10000 (100x100) 个像素点，它每一个像素点在内存空间所占的空间大小是8bite,即8位
 *              name 它对应的 <bit_depth> 即为 8 --> CV_8
 *          +-- S|U|F
 *              S : signed int , 有符号整形
 *              U : unsigned int , 无符号整形
 *              F : float , 单精度浮点型
 *          +-- C<number_of_channels>  图像的通道数
 *
 *          CV_8UC3 即 8位无符号的3通道（RGB 彩色）图像
 *
 * 2. 各 Bite 的数据
 *      +-- 8U  无符号的8位图     CV_8UC1，CV_8UC2，CV_8UC3，CV_8UC4     取值范围 0~255
 *      +-- 8S  有符号的8位图     CV_8SC1，CV_8SC2，CV_8SC3，CV_8SC4     取值范围 -128~127
 *      +-- 16U 无符号的16位图    CV_16UC1，CV_16UC2，CV_16UC3，CV_16UC4 取值范围 0~65535
 *      +-- 16S 有符号的16位图    CV_16SC1，CV_16SC2，CV_16SC3，CV_16SC4 取值范围 -32768~32767
 *      +-- 32S 无符号的32位图    CV_32SC1，CV_32SC2，CV_32SC3，CV_32SC4 取值范围 2147483648~2147483647
 *      +-- 32F 浮点型32位图      CV_32FC1，CV_32FC2，CV_32FC3，CV_32FC4 取值范围 1.18*(10[-38次方])~3.40*(10[38次方])
 *      +-- 64F 浮点型64位图      CV_64FC1，CV_64FC2，CV_64FC3，CV_64FC4 取值范围 2.23*(10[-308次方])~1.79*(10[308次方])
 *      +-- 1位  IPL_DEPTH_1U 取值范围 0~1
 *
 * OpenCV Scalar 说明：
 *
 * opencv 中用以表示通道值对象，其构造值根据 CvType 通道 S|U|F 来决定取值范围。
 *
 * 构造函数：
 *      new Scalar(param)
 *      new Scalar(param,param)
 *      new Scalar(param,param,param)
 *      new Scalar(param,param,param,param)
 *
 *      1. 构造函数的入参（值）的数量 <= 通道数量 [如果是2通道图像，用4个参数的构造函数，后面2个参数不起作用]
 *      2. 构造函数的入参（值）的数量 < 通道数量 时，未传入值的通道值为0
 *      3. 多通道图像时，入参顺序 new Scalar(B,G,R,alpha)
 *          举例：
 *          构造蓝色的图，CvType.8UC3 [3通道,RGB 彩色] , new Salar(255), 后面2个参数默认为0
 *          构造绿色的图，CvType.8UC3 [3通道,RGB 彩色] , new Salar(0,255), 后面1个参数默认为0
 *          构造红色的图，CvType.8UC3 [3通道,RGB 彩色] , new Salar(0,0,255)
 *          构造蓝色的半透明图，CvType.8UC3 [4通道,RGBA 彩色+alpha 图像] , new Salar(255,0,0,125) 即可
 */

class Mat_Activity : AppCompatActivity() {

    lateinit var dir: String
    lateinit var disposable: Disposable

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_mat)

        dir = FileUtil.getDir()

        seekBar1.setIndicatorTextFormat("Scalar(\${PROGRESS})")
        seekBar1.onSeekChangeListener = object : OnSeekChangeListener {
            override fun onSeeking(seekParams: SeekParams) {
                var mat =
                    Mat(Size(100.0, 100.0), CvType.CV_8UC1, Scalar(seekParams.progress.toDouble()))
                iv1.setImageBitmap(ImageUtil.matToBitmap(mat))
                mat.release()
            }

            override fun onStartTrackingTouch(seekBar: IndicatorSeekBar) {
            }

            override fun onStopTrackingTouch(seekBar: IndicatorSeekBar) {
            }

        }

        var rV = 0
        var gV = 0
        var bV = 0
        var aV = 255

        seekBar2.setIndicatorTextFormat("R: \${PROGRESS}")
        seekBar2.onSeekChangeListener = object : OnSeekChangeListener {
            override fun onSeeking(seekParams: SeekParams) {
                rV = seekParams.progress
                setCV_8UC4Image(rV.toDouble(), gV.toDouble(), bV.toDouble(), aV.toDouble())

            }

            override fun onStartTrackingTouch(seekBar: IndicatorSeekBar) {
            }

            override fun onStopTrackingTouch(seekBar: IndicatorSeekBar) {
            }

        }

        seekBar3.setIndicatorTextFormat("G: \${PROGRESS}")
        seekBar3.onSeekChangeListener = object : OnSeekChangeListener {
            override fun onSeeking(seekParams: SeekParams) {
                gV = seekParams.progress
                setCV_8UC4Image(rV.toDouble(), gV.toDouble(), bV.toDouble(), aV.toDouble())

            }

            override fun onStartTrackingTouch(seekBar: IndicatorSeekBar) {
            }

            override fun onStopTrackingTouch(seekBar: IndicatorSeekBar) {
            }

        }

        seekBar4.setIndicatorTextFormat("B: \${PROGRESS}")
        seekBar4.onSeekChangeListener = object : OnSeekChangeListener {
            override fun onSeeking(seekParams: SeekParams) {
                bV = seekParams.progress
                setCV_8UC4Image(rV.toDouble(), gV.toDouble(), bV.toDouble(), aV.toDouble())

            }

            override fun onStartTrackingTouch(seekBar: IndicatorSeekBar) {
            }

            override fun onStopTrackingTouch(seekBar: IndicatorSeekBar) {
            }

        }
        seekBar5.setIndicatorTextFormat("A: \${PROGRESS}")
        seekBar5.onSeekChangeListener = object : OnSeekChangeListener {
            override fun onSeeking(seekParams: SeekParams) {
                aV = seekParams.progress
                setCV_8UC4Image(rV.toDouble(), gV.toDouble(), bV.toDouble(), aV.toDouble())
            }

            override fun onStartTrackingTouch(seekBar: IndicatorSeekBar) {
            }

            override fun onStopTrackingTouch(seekBar: IndicatorSeekBar) {
            }

        }

        val sourceImage = Mat.eye(Size(100.0, 100.0), CvType.CV_8UC3)
        disposable=Observable.interval(1000,TimeUnit.MILLISECONDS)
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe {
                // 随机给通道填充值， randu(src,low,high)   low=最小值， high=最大值，  0~255
                Core.randu(sourceImage, 0.0, 255.0)
                iv3.setImageBitmap(ImageUtil.matToBitmap(sourceImage))
            }



    }


    private fun setCV_8UC4Image(rv: Double, gv: Double, bv: Double, av: Double) {
        tv1.text="Scalar($rv, $gv,$bv, $av)"
        var mat = Mat(Size(100.0, 100.0), CvType.CV_8UC4, Scalar(rv, gv, bv, av))
        iv2.setImageBitmap(ImageUtil.matToBitmap(mat))
        mat.release()
    }

    override fun onDestroy() {
        super.onDestroy()
        if (!disposable.isDisposed)
            disposable.dispose()
    }

}