package com.example.opentest.ui

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.opentest.R
import com.example.opentest.opencv.ImageUtil
import com.example.opentest.util.TimberUtil
import kotlinx.android.synthetic.main.activity_gray_rgb.*
import org.opencv.android.Utils
import org.opencv.core.CvType
import org.opencv.core.Mat
import org.opencv.imgproc.Imgproc


/**
 * 灰度和彩色图像转换
 */
class Gray_RGB_Activity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_gray_rgb)

        /**
         * 1. 只传 filename flags 默认为 1 彩色图
         * 2. flags = Imgcodecs 下 CV_LOAD 常量
         *      +-- IMREAD_UNCHANGED = -1;   载入包含 Alpha 通道时，需要
         *      +-- IMREAD_GRAYSCALE = 0;    加载一个张灰度图，设置该值，图像将会转换为灰度后返回
         *      +-- IMREAD_COLOR = 1;        加载一张彩色图，设置为该值，图像将会转化为3通道彩色图返回
         *      +-- IMREAD_ANYDEPTH = 2;     如果载入的图像为16Bite 或者 32Bite 则载入对应 Bite 的图像，反之载入的图像为8Bite
         *      +-- IMREAD_ANYCOLOR = 4;     如果载入的图像为16Bite 或者 32Bite 则载入对应 Bite 的图像，反之载入的图像为8Bite
         */
        var mat = Utils.loadResource(this, R.mipmap.liuyifei1)


        btn1.setOnClickListener {
            var toMat = Mat()
            Imgproc.cvtColor(mat, toMat, Imgproc.COLOR_RGB2GRAY)
            iv2.setImageBitmap(ImageUtil.matToBitmap(toMat))
        }

        /**
         * 伪彩色处理
         * 其实R，G，B三个通道上的值相等时，所呈现的颜色就是灰色（很容易验证），
         * 只有亮跟暗的区别，值越大就越亮，越小就越暗。也就是从灰度图中的亮度变成了彩色图中的灰色了。
         * 所以使用这个函数将灰度图转换成彩色图时，如果出现的还是黑白图，不要觉得是程序出错了。
         */
        btn3.setOnClickListener {
            //灰度
            var grayMat = Mat()
            Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_RGB2GRAY)
            //彩色灰图
            var toMat = Mat()
            Imgproc.cvtColor(grayMat, toMat, Imgproc.COLOR_GRAY2RGB)
            //初始化同样大小的Mat
            var newMat = Mat.zeros(toMat.rows(), toMat.cols(), CvType.CV_8UC3)
            //伪彩色处理
            for (i in 0 until toMat.rows()) {
                for (j in 0 until toMat.cols()) {
                    var doubleArray = DoubleArray(3)
                    var g = grayMat[i, j][0]
                    if (g <= 127) {
                        doubleArray[0] = 0.0
                    } else if (g <= 191) {
                        doubleArray[0] = 4 * g - 510
                    } else {
                        doubleArray[0] = 255.0
                    }

                    if (g <= 63) {
                        doubleArray[1] = 254 - 4 * g
                    } else if (g <= 127) {
                        doubleArray[1] = 4 * g - 254
                    } else if (g <= 191) {
                        doubleArray[1] = 255.0
                    } else {
                        doubleArray[1] = 1022 - 4 * g
                    }
                    if (g <= 63) {
                        doubleArray[2] = 255.0
                    } else if (g <= 127) {
                        doubleArray[2] = 510 - 4 * g
                    } else {
                        doubleArray[2] = 0.0
                    }
                    newMat.put(i, j, doubleArray[0], doubleArray[1], doubleArray[2])
                }
            }

            iv4.setImageBitmap(ImageUtil.matToBitmap(newMat))
        }

        /**
         * 其实R，G，B三个通道上的值相等时，所呈现的颜色就是灰色（很容易验证），
         * 只有亮跟暗的区别，值越大就越亮，越小就越暗。也就是从灰度图中的亮度变成了彩色图中的灰色了。
         * 所以使用这个函数将灰度图转换成彩色图时，如果出现的还是黑白图，不要觉得是程序出错了。
         */
        btn4.setOnClickListener {

            var p = 0.2989
            var q = 0.5870
            var t = 0.1140

            var i = 0
            var j = 5

            TimberUtil.logI("原始R: " + mat[i, j][0])
            TimberUtil.logI("原始G: " + mat[i, j][1])
            TimberUtil.logI("原始B: " + mat[i, j][2])
            //灰度
            var grayMat = Mat()
            Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_RGB2GRAY)
            TimberUtil.logI("灰度: " + grayMat[i, j][0])

            //彩色灰图
            var toMat = Mat()
            Imgproc.cvtColor(grayMat, toMat, Imgproc.COLOR_GRAY2RGB, 3)

            TimberUtil.logI("彩色R: " + toMat[i, j][0])
            TimberUtil.logI("彩色G: " + toMat[i, j][1])
            TimberUtil.logI("彩色B: " + toMat[i, j][2])
            for (i in 0 until toMat.rows()) {
                for (j in 0 until toMat.cols()) {
                    //灰度值
                    var g = grayMat[i, j][0]

                    var R = mat[i, j][0]
                    var G = mat[i, j][1]
                    var B = toMat[i, j][2]

                    // 灰度g=p*R+q*G+t*B（其中p=0.2989,q=0.5870,t=0.1140），
                    // 于是B=(g-p*R-q*G)/t。
                    // 于是我们只要保留R和G两个颜色分量，再加上灰度图g，就可以回复原来的RGB图像。

                    // var R_new = (g - q * G - t * B) / p

                    //  var G_new = (g - p * R - t * B) / q

                    var B_new = (g - p * R - q * G) / t
                    toMat.put(i, j, toMat[i, j][0], toMat[i, j][1], B_new)
                }
            }
            TimberUtil.logI("newR: " + toMat[i, j][0])

            TimberUtil.logI("newG: " + toMat[i, j][1])

            TimberUtil.logI("newB: " + toMat[i, j][2])

            var newMat = Mat()
            Imgproc.cvtColor(toMat, newMat, Imgproc.COLOR_RGB2BGR)
            iv5.setImageBitmap(ImageUtil.matToBitmap(newMat))

        }


        /**
         * COLOR_RGB2RGBA
         */
        btn2.setOnClickListener {
            var toMat = Mat()
            Imgproc.cvtColor(mat, toMat, Imgproc.COLOR_RGB2RGBA)
            iv3.setImageBitmap(ImageUtil.matToBitmap(toMat))
        }


    }

}