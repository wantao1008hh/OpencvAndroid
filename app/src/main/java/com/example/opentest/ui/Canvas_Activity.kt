package com.example.opentest.ui

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.opentest.R
import com.example.opentest.opencv.ImageUtil
import com.example.opentest.util.TimberUtil
import kotlinx.android.synthetic.main.activity_canvas_.*
import org.opencv.core.*
import org.opencv.core.Scalar
import org.opencv.imgproc.Imgproc
import org.opencv.imgproc.Imgproc.LINE_AA


class Canvas_Activity : AppCompatActivity() {

    lateinit var mRect: Rect

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_canvas_)

        iv1.post {
            mRect = Rect(0, 0, iv1.width, iv1.height)
            TimberUtil.logI("Rect: (" + mRect.width + "," + mRect.height + ")")
        }
        /**
         * 在图像上画一个椭圆(ellipse)
         *
         * 构造函数 ellipse(Mat img, Point center, Size axes, double angle, double startAngle, double endAngle, Scalar color, int thickness, int lineType, int shift)
         *
         * img : 类型 Mat ， 输入图像
         * center : 类型 Point ， 圆心坐标。比如你想把图像画在输入图像的中间， 取 new Point(img.width/2   , img.height/2) 即可
         * axes : 类型 Size ，图像以中心点从最小角度开始延伸出去的轴长。最短为 width，最大为 height，如果 width、height 相等，并且角度0-360则画出来的图像为圆形
         * angle : 倾斜角度
         * startAngle : 开始角度
         * endAngle : 结束角度
         * color : 线条颜色
         * thickness : 线宽度
         * lineType : 线条类型 4,8,16   Imgproc.LINE_<str>
         *     -- Imgproc.LINE_4   值 4 ，4连通线性
         *     -- Imgproc.LINE_8   值 8 ，8连通线性
         *     -- Imgproc.LINE_AA  值 16，抗锯齿线性
         * shift : 圆心坐标点和数轴的精度
         *
         * 对角度的理解可以参考 （https://blog.csdn.net/gxiaob/article/details/9396955）
         */
        btn1.setOnClickListener {
            var mat = Mat(
                Size(mRect.width.toDouble(), mRect.height.toDouble()), CvType.CV_8UC3,
                Scalar.all(255.0)
            )
            Imgproc.ellipse(
                mat,
                Point(mat.width() / 2.0, mat.height() / 2.0),
                Size(100.0, 50.0), 0.0, 180.0, -180.0,
                Scalar(255.0, 129.0, 0.0),
                2,
                Imgproc.LINE_8,
                0
            )

            iv1.setImageBitmap(ImageUtil.matToBitmap(mat))


        }
        //画线
        btn2.setOnClickListener {
            var mat = Mat(
                Size(mRect.width.toDouble(), mRect.height.toDouble()), CvType.CV_8UC3,
                Scalar.all(255.0)
            )
            Imgproc.line(
                mat,
                Point(0.0, mat.height() / 2.0),
                Point(mat.width().toDouble(), mat.height() / 2.0),
                Scalar.all(0.0),
                1,
                8,
                0
            )

            iv1.setImageBitmap(ImageUtil.matToBitmap(mat))
        }

        /**
         * 画实心圆
         *
         * circle(Mat img, Point center, int radius, Scalar color, int thickness, int lineType, int shift)
         * img : 类型 Mat ， 输入图像
         * center : 类型 Point ， 圆心坐标。比如你想把图像画在输入图像的中间， 取 new Point(img.width/2   , img.height/2) 即可
         * radius : 圆的半径长度
         * color  : 圆的颜色
         * thickness : 描边线宽， -1为没有描边
         * lineType  : 线类型，画圆，建议取 LINE_AA 抗锯齿
         * shift : 圆心坐标点和数轴的精度 填 0 即可
         */
        //画实心圆线
        btn3.setOnClickListener {
            var mat = Mat(
                Size(mRect.width.toDouble(), mRect.height.toDouble()), CvType.CV_8UC3,
                Scalar.all(255.0)
            )
            Imgproc.circle(
                mat,
                Point(mat.width()/2.0, mat.height() / 2.0),
                50,
                Scalar.all(0.0),
                -1,
                LINE_AA,
                0
            )



            iv1.setImageBitmap(ImageUtil.matToBitmap(mat))
        }


        //画空心圆
        btn4.setOnClickListener {
            var mat = Mat(
                Size(mRect.width.toDouble(), mRect.height.toDouble()), CvType.CV_8UC3,
                Scalar.all(255.0)
            )
            Imgproc.circle(
                mat,
                Point(mat.width()/2.0, mat.height() / 2.0),
                50,
                Scalar.all(0.0),
                1,
                LINE_AA,
                0
            )
            iv1.setImageBitmap(ImageUtil.matToBitmap(mat))
        }

    }
}